// Miguel Ramos, 2012.
// vim: set et sw=4 sts=4 ts=8:

// We have the [xyz] strides in the constant cache.
// We want to compute a linearized local_ID.
ALU: KCACHE_BANK0(0) KCACHE_MODE0.CF_KCACHE_LOCK_1 BARRIER;

    // PV.[xyzw] <- local_ID.[xyzw] * local_stride.[xyzw]
    MUL_UINT24: DST_CHAN.CHAN_X
        SRC0_SEL.GPR(0) SRC0_CHAN.CHAN_X
        SRC1_SEL.Kcache_bank0(4) SRC1_CHAN.CHAN_X;
    MUL_UINT24: DST_CHAN.CHAN_Y
        SRC0_SEL.GPR(0) SRC0_CHAN.CHAN_Y
        SRC1_SEL.Kcache_bank0(4) SRC1_CHAN.CHAN_Y;
    MUL_UINT24: DST_CHAN.CHAN_Z
        SRC0_SEL.GPR(0) SRC0_CHAN.CHAN_Z
        SRC1_SEL.Kcache_bank0(4) SRC1_CHAN.CHAN_Z;
    MUL_UINT24: DST_CHAN.CHAN_W
        SRC0_SEL.GPR(0) SRC0_CHAN.CHAN_W
        SRC1_SEL.Kcache_bank0(4) SRC1_CHAN.CHAN_W LAST;

    // R2.z <- sum(PV.[xyzw])
    ADD_INT: DST_CHAN.CHAN_X
        SRC0_SEL.ALU_SRC_PV SRC0_CHAN.CHAN_X
        SRC1_SEL.ALU_SRC_PV SRC1_CHAN.CHAN_Y;
    ADD_INT: DST_CHAN.CHAN_Y
        SRC0_SEL.ALU_SRC_PV SRC0_CHAN.CHAN_Z
        SRC1_SEL.ALU_SRC_PV SRC1_CHAN.CHAN_W LAST;
    ADD_INT:
        DST_GPR(2) DST_CHAN.CHAN_Z
        SRC0_SEL.ALU_SRC_PV SRC0_CHAN.CHAN_X
        SRC1_SEL.ALU_SRC_PV SRC1_CHAN.CHAN_Y WRITE_MASK LAST;

    // PV.[xyzw] <- group_ID.[xyzw] * group_stride.[xyzw]
    MUL_UINT24: DST_CHAN.CHAN_X
        SRC0_SEL.GPR(1) SRC0_CHAN.CHAN_X
        SRC1_SEL.Kcache_bank0(5) SRC1_CHAN.CHAN_X;
    MUL_UINT24: DST_CHAN.CHAN_Y
        SRC0_SEL.GPR(1) SRC0_CHAN.CHAN_Y
        SRC1_SEL.Kcache_bank0(5) SRC1_CHAN.CHAN_Y;
    MUL_UINT24: DST_CHAN.CHAN_Z
        SRC0_SEL.GPR(1) SRC0_CHAN.CHAN_Z
        SRC1_SEL.Kcache_bank0(5) SRC1_CHAN.CHAN_Z;
    MUL_UINT24: DST_CHAN.CHAN_W
        SRC0_SEL.GPR(1) SRC0_CHAN.CHAN_W
        SRC1_SEL.Kcache_bank0(5) SRC1_CHAN.CHAN_W LAST;

    // R2.y <- sum(PV.[xyzw])
    ADD_INT: DST_CHAN.CHAN_X
        SRC0_SEL.ALU_SRC_PV SRC0_CHAN.CHAN_X
        SRC1_SEL.ALU_SRC_PV SRC1_CHAN.CHAN_Y;
    ADD_INT: DST_CHAN.CHAN_Y
        SRC0_SEL.ALU_SRC_PV SRC0_CHAN.CHAN_Z
        SRC1_SEL.ALU_SRC_PV SRC1_CHAN.CHAN_W LAST;
    ADD_INT:
        DST_GPR(2) DST_CHAN.CHAN_Y
        SRC0_SEL.ALU_SRC_PV SRC0_CHAN.CHAN_X
        SRC1_SEL.ALU_SRC_PV SRC1_CHAN.CHAN_Y WRITE_MASK LAST;

    // R2.x <- R2.y + R2.z
    ADD_INT:
        DST_GPR(2) DST_CHAN.CHAN_X
        SRC0_SEL.GPR(2) SRC0_CHAN.CHAN_Y
        SRC1_SEL.GPR(2) SRC1_CHAN.CHAN_Z WRITE_MASK LAST;

    // Let's prepare our output R3 with interesting stuff.

    LSHL_INT: DST_CHAN.CHAN_Y
        SRC0_SEL.ALU_SRC_SIMD_ID
        SRC1_SEL.ALU_SRC_LITERAL SRC1_CHAN.CHAN_X;
    LSHL_INT: DST_CHAN.CHAN_Z
        SRC0_SEL.ALU_SRC_HW_THREADGRP_ID
        SRC1_SEL.ALU_SRC_LITERAL SRC1_CHAN.CHAN_X LAST;
    0x00000010 0x00000000;
    OR_INT:
        DST_GPR(3) DST_CHAN.CHAN_Y
        SRC0_SEL.ALU_SRC_PV SRC0_CHAN.CHAN_Y
        SRC1_SEL.ALU_SRC_HW_ALU_ODD WRITE_MASK;
    OR_INT:
        DST_GPR(3) DST_CHAN.CHAN_Z
        SRC0_SEL.ALU_SRC_PV SRC0_CHAN.CHAN_Z
        SRC1_SEL.ALU_SRC_HW_WAVE_ID WRITE_MASK;
    MOV:
        DST_GPR(3) DST_CHAN.CHAN_X
        SRC0_SEL.GPR(2) SRC0_CHAN.CHAN_Y WRITE_MASK;
    MOV:
        DST_GPR(3) DST_CHAN.CHAN_W
        SRC0_SEL.ALU_SRC_TIME_LO WRITE_MASK LAST;

MEM_RAT_CACHELESS:
    RAT_ID(11) RAT_INST.EXPORT_RAT_INST_STORE_RAW TYPE(1) RW_GPR(3) INDEX_GPR(2) ELEM_SIZE(3)
    COMP_MASK(15) BARRIER;

NOP: BARRIER END_OF_PROGRAM;

end;
